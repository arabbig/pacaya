package edu.jhu.pacaya.util.semiring;

import org.junit.Test;

import edu.jhu.pacaya.autodiff.Tensor;
import edu.jhu.pacaya.util.semiring.Algebra;
import edu.jhu.pacaya.util.semiring.Algebras;
import edu.jhu.pacaya.util.semiring.LogSemiring;
import edu.jhu.pacaya.util.semiring.RealAlgebra;
import edu.jhu.prim.util.Timer;

/**
 * Results:
 * 
 * In the method, testSpeedOfLambdasIndirectCalls() we find that the JIT can be "broken" such that
 * the desired inlining does not occur. This is exemplified in its slow performance below and also
 * by examining the assembly generated by the JIT.
 * 
testSpeedOfMacros
round=0 total(ms)=2412.0000
round=1 total(ms)=1744.0000
round=2 total(ms)=1691.0000
round=3 total(ms)=1704.0000
testSpeedOfStaticFinals
round=0 total(ms)=1719.0000
round=1 total(ms)=1735.0000
round=2 total(ms)=1712.0000
round=3 total(ms)=1696.0000
testSpeedOfLambdasLocalVars
round=0 total(ms)=3813.0000
round=1 total(ms)=2985.0000
round=2 total(ms)=1906.0000
round=3 total(ms)=1914.0000
testSpeedOfLambdasDirectCalls
round=0 total(ms)=3867.0000
round=1 total(ms)=2930.0000
round=2 total(ms)=1701.0000
round=3 total(ms)=1779.0000
testSpeedOfLambdasIndirectCalls
round=0 total(ms)=3812.0000
round=1 total(ms)=3453.0000
round=2 total(ms)=2934.0000
round=3 total(ms)=2978.0000
 * 
 * For some reason, we do not see the same behavior when using two Algebras.
 * 
testSpeedOfTensorAddMacros
round=0 total(ms)=2466.0000
round=1 total(ms)=2474.0000
round=2 total(ms)=2346.0000
round=3 total(ms)=2340.0000
testSpeedOfTensorAddSemiring
round=0 total(ms)=2417.0000
round=1 total(ms)=2310.0000
round=2 total(ms)=2275.0000
round=3 total(ms)=2293.0000
testSpeedOfTensorAddSemiringIndirect
round=0 total(ms)=2307.0000
round=1 total(ms)=2309.0000
round=2 total(ms)=2325.0000
round=3 total(ms)=2293.0000
 * 
 * @author mgormley
 */
public class JavaJitInliningSpeedTest {

    static final int numRounds = 4;
    static final int numTrials = 10000;
    static final int size = 10000;
    
    @Test
    public void testSpeedOfMacros() { 
        System.out.println("testSpeedOfMacros");
        for (int round=0; round<numRounds; round++) {
            Timer t = new Timer();
            t.start();        
            for (int trial=0; trial<numTrials; trial++) {
                long[] dst = new long[size];
                long[] src1 = new long[size];
                long[] src2 = new long[size];
                for (int i=0; i<dst.length; i++) {
                    dst[i] = src1[i] | src2[i];
                }
                for (int i=0; i<dst.length; i++) {
                    dst[i] = src1[i] & src2[i];
                }
                for (int i=0; i<dst.length; i++) {
                    dst[i] = src1[i] ^ src2[i];
                }
            }
            t.stop();            
            System.out.println(String.format("round=%d total(ms)=%7.4f", round, t.totMs()));
        }
    }
    
    
    // The function in the inner loop
    private static final long or_word(long a, long b) {
        return a | b;
    }
    private static final long and_word(long a, long b) {
        return a & b;
    }
    private static final long xor_word(long a, long b) {
        return a ^ b;
    }

    // The iterator function
    private static final void blit_or_word(long[] dst, long[] src1, long[] src2) {
        for (int i = 0; i < dst.length; i++) { // simple loop
            dst[i] = or_word(src1[i], src2[i]); // around a simple loop body
        }
    }
    private static final void blit_and_word(long[] dst, long[] src1, long[] src2) {
        for (int i = 0; i < dst.length; i++) { // simple loop
            dst[i] = and_word(src1[i], src2[i]); // around a simple loop body
        }
    }
    private static final void blit_xor_word(long[] dst, long[] src1, long[] src2) {
        for (int i = 0; i < dst.length; i++) { // simple loop
            dst[i] = xor_word(src1[i], src2[i]); // around a simple loop body
        }
    }
    
    @Test
    public void testSpeedOfStaticFinals() {
        System.out.println("testSpeedOfStaticFinals");
        for (int round=0; round<numRounds; round++) {
            Timer t = new Timer();
            t.start();        
            for (int trial=0; trial<numTrials; trial++) {
                long[] dst = new long[size];
                long[] src1 = new long[size];
                long[] src2 = new long[size];
                blit_or_word(dst, src1, src2);
                blit_and_word(dst, src1, src2);
                blit_xor_word(dst, src1, src2);
            }
            t.stop();            
            System.out.println(String.format("round=%d total(ms)=%7.4f", round, t.totMs()));
        }
    }
    
    public interface FnLongLongToLong {
        public long call(long idx, long val);
    }
    
    // The function in the inner loop
    private static class OrWordFn implements FnLongLongToLong {
        public long call(long a, long b) {
            return a | b;
        }
    }
    private static class AndWordFn implements FnLongLongToLong {
        public long call(long a, long b) {
            return a & b;
        }
    }
    private static class XorWordFn implements FnLongLongToLong {
        public long call(long a, long b) {
            return a ^ b;
        }
    }

    // The iterator function
    private static final void blit(long[] dst, long[] src1, long[] src2, FnLongLongToLong fn) {
        for (int i = 0; i < dst.length; i++) { // simple loop
            dst[i] = fn.call(src1[i], src2[i]); // around a simple loop body
        }
    }
    
    @Test
    public void testSpeedOfLambdasDirectCalls() {
        System.out.println("testSpeedOfLambdasDirectCalls");
        for (int round=0; round<numRounds; round++) {
            Timer t = new Timer();
            t.start();        
            for (int trial=0; trial<numTrials; trial++) {
                long[] dst = new long[size];
                long[] src1 = new long[size];
                long[] src2 = new long[size];
                blit(dst, src1, src2, new OrWordFn());
                blit(dst, src1, src2, new AndWordFn());
                blit(dst, src1, src2, new XorWordFn());
            }
            t.stop();            
            System.out.println(String.format("round=%d total(ms)=%7.4f", round, t.totMs()));
        }
    }

    @Test
    public void testSpeedOfLambdasIndirectCalls() {
        System.out.println("testSpeedOfLambdasIndirectCalls");
        final OrWordFn fn1 = new OrWordFn();
        final AndWordFn fn2 = new AndWordFn();
        final XorWordFn fn3 = new XorWordFn();

        runSpeedOfLambdas1(fn1, fn2, fn3);
    }

    private static final void runSpeedOfLambdas1(FnLongLongToLong fn1, FnLongLongToLong fn2, FnLongLongToLong fn3) {
        for (int round=0; round<numRounds; round++) {
            Timer t = new Timer();
            t.start();        
            for (int trial=0; trial<numTrials; trial++) {
                long[] dst = new long[size];
                long[] src1 = new long[size];
                long[] src2 = new long[size];
                blit(dst, src1, src2, fn1);
                blit(dst, src1, src2, fn2);
                blit(dst, src1, src2, fn3);
            }
            t.stop();            
            System.out.println(String.format("round=%d total(ms)=%7.4f", round, t.totMs()));
        }
    }
    
    @Test
    public void testSpeedOfLambdasLocalVars() {
        System.out.println("testSpeedOfLambdasLocalVars");
        final OrWordFn fn1 = new OrWordFn();
        final AndWordFn fn2 = new AndWordFn();
        final XorWordFn fn3 = new XorWordFn();

        for (int round=0; round<numRounds; round++) {
            Timer t = new Timer();
            t.start();        
            for (int trial=0; trial<numTrials; trial++) {
                long[] dst = new long[size];
                long[] src1 = new long[size];
                long[] src2 = new long[size];
                blit(dst, src1, src2, fn1);
                blit(dst, src1, src2, fn2);
                blit(dst, src1, src2, fn3);
            }
            t.stop();            
            System.out.println(String.format("round=%d total(ms)=%7.4f", round, t.totMs()));
        }
    }
    
    @Test
    public void testSpeedOfTensorAddMacros() {
        System.out.println("testSpeedOfTensorAddMacros");

        for (int round=0; round<numRounds; round++) {
            Timer t = new Timer();
            t.start();        
            for (int trial=0; trial<numTrials; trial++) {
                Tensor t1 = new Tensor(new RealAlgebra(), size);
                Tensor t2 = new Tensor(new RealAlgebra(), size);
                {
                    double[] vals1 = t1.getValues();
                    double[] vals2 = t2.getValues();
                    for (int i=0; i<vals1.length; i++) {
                        vals1[i] = vals1[i] * vals2[i];
                    }
                }
                Tensor t3 = new Tensor(new LogSemiring(), size);
                Tensor t4 = new Tensor(new LogSemiring(), size);
                {
                    double[] vals1 = t3.getValues();
                    double[] vals2 = t4.getValues();
                    for (int i=0; i<vals1.length; i++) {
                        vals1[i] = vals1[i] + vals2[i];
                    }
                }
            }
            t.stop();            
            System.out.println(String.format("round=%d total(ms)=%7.4f", round, t.totMs()));
        }
    }
    
    @Test
    public void testSpeedOfTensorAddSemiring() {
        System.out.println("testSpeedOfTensorAddSemiring");

        for (int round=0; round<numRounds; round++) {
            Timer t = new Timer();
            t.start();        
            for (int trial=0; trial<numTrials; trial++) {
                Tensor t1 = new Tensor(new RealAlgebra(), size);
                Tensor t2 = new Tensor(new RealAlgebra(), size);
                t1.elemMultiply(t2);
                Tensor t3 = new Tensor(new LogSemiring(), size);
                Tensor t4 = new Tensor(new LogSemiring(), size);
                t3.elemMultiply(t4);
            }
            t.stop();            
            System.out.println(String.format("round=%d total(ms)=%7.4f", round, t.totMs()));
        }
    }
    
    @Test
    public void testSpeedOfTensorAddSemiringIndirect() {
        System.out.println("testSpeedOfTensorAddSemiringIndirect");
        RealAlgebra s1 = Algebras.REAL_ALGEBRA; //new RealAlgebra();
        LogSemiring s2 = Algebras.LOG_SEMIRING; //new LogSemiring();
        runSpeedTestSemiringIndirect(s1, s2);
    }

    private void runSpeedTestSemiringIndirect(Algebra s1, Algebra s2) {
        for (int round=0; round<numRounds; round++) {
            Timer t = new Timer();
            t.start();        
            for (int trial=0; trial<numTrials; trial++) {
                Tensor t1 = new Tensor(s1, size);
                Tensor t2 = new Tensor(s1, size);
                t1.elemMultiply(t2);
                Tensor t3 = new Tensor(s2, size);
                Tensor t4 = new Tensor(s2, size);
                t3.elemMultiply(t4);
            }
            t.stop();            
            System.out.println(String.format("round=%d total(ms)=%7.4f", round, t.totMs()));
        }
    }
    
    public static void main(String[] args) {
        JavaJitInliningSpeedTest test = new JavaJitInliningSpeedTest();
        if (false) {
            test.testSpeedOfMacros();
            test.testSpeedOfStaticFinals();
            test.testSpeedOfLambdasLocalVars();
            test.testSpeedOfLambdasDirectCalls();
            test.testSpeedOfLambdasIndirectCalls();
        } 
        if (true) {
            test.testSpeedOfTensorAddMacros();
            test.testSpeedOfTensorAddSemiring();
            test.testSpeedOfTensorAddSemiringIndirect();
        }
    }

}
