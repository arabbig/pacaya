<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [ <!ATTLIST code id   ID    #REQUIRED> ]>
<root>
	<code id="setup">
	    <![CDATA[
# ---------- Sets, Parameters ----------
param InputSent := "input.sent";

# input.sent contains "<sentence id, token id> word"
set AllTokens := { read InputSent as "<1n,2n>" };
set Sents := proj(AllTokens,<1>);
set TempTokens := proj(AllTokens,<2>);
set Tokens[<s> in Sents] := { <i> in  TempTokens with <s,i> in AllTokens };
param Length[<s> in Sents] := max(Tokens[s]);
param Word[AllTokens] := read InputSent as "<1n,2n> 3s";
set AllWords := { read InputSent as "<3s>" }; 
# This gives an error: set AllWords := {union <s,i> in AllTokens: Word[s,i]};

do print AllTokens;
do print Sents;
do forall <s> in Sents do print Tokens[s];
do forall <s,i> in AllTokens do print Word[s,i];

# The following 4 lines don't work
# The domain of WordPairs is pairs of words
#set Words[<s> in Sents] := { <w> in AllWords with Word[s,i] == w};
#set WordPairs[<s> in Sents] := Words[s] * Words[s];
#set AllWordPairs := union <s> in Sents: WordPairs;

# The domain of Arcs is pairs of token indices
set Arcs[<s> in Sents] := {<i,j> in Tokens[s] * Tokens[s] with i != j};
set TempArcs := union <s> in Sents: Arcs[s];
set AllArcs := { <s,i,j> in Sents*TempArcs with <i,j> in Arcs[s] }; # TODO: this should be horribly slow

var arc[AllArcs] binary;
       
# This constraint is optional, but we include it for all formulations    
# The wall has one outgoing arc
subto one_child_for_wall:
    forall <s> in Sents:
       1 == sum <j> in { 1 to Length[s] }: arc[s,0,j];
       
	    ]]>
	</code>
	<code id="weights">
	    <![CDATA[
# ---------- Weights ----------
# input.chooseweights contains "<parent word, lr, child word> weight"
param InputChooseWeights := "input.chooseweights";
set ChooseWeightSet := { read InputChooseWeights as "<1s, 2s, 3s>" };
param ChooseWeight[ChooseWeightSet] := read InputChooseWeights as "<1s, 2s, 3s> 4n";

# input.stopweights contains "<word, l/r, 0/1> weight" where 0/1 is for adjacency
param InputStopWeights := "input.stopweights";
set LR := {"l","r"};
#Note: faster, but not right for one sentence only: set StopSet := AllWords * LR * {0, 1};
set StopWeightSet := { read InputStopWeights as "<1s,2s,3n>" };
param StopWeight[StopWeightSet] := read InputStopWeights as "<1s,2s,3n> 4n";

	    ]]>
	</code>
	<code id="weights-delta">
	    <![CDATA[
# ---------- Weights ----------
# input.chooseweights.delta contains "<parent word, lr, child word, delta id> weight"
param InputChooseWeights := "input.chooseweights.delta";
set ChooseWeightDeltaSet := { read InputChooseWeights as "<1s, 2s, 3s, 4s>" };
param ChooseWeightDelta[ChooseWeightDeltaSet] := read InputChooseWeights as "<1s, 2s, 3s, 4s> 5n";

#TODO: add deltas for stopweights
# input.stopweights contains "<word, l/r, 0/1> weight" where 0/1 is for adjacency
param InputStopWeights := "input.stopweights";
set LR := {"l","r"};
#Note: faster, but not right for one sentence only: set StopSet := AllWords * LR * {0, 1};
set StopSet := { read InputStopWeights as "<1s,2s,3n>" };
param StopWeight[StopSet] := read InputStopWeights as "<1s,2s,3n> 4n";


# ---------- Sets for Deltas ----------
set ChooseWeightSet := proj(ChooseWeightDeltaSet, <1,2,3>);
set ParentWordsAndLR := proj(ChooseWeightDeltaSet, <1,2>);
set AllChildWordsAndDeltas := proj(ChooseWeightDeltaSet, <3,4>);
set ChildWordsAndDeltas[<parentw, lr> in ParentWordsAndLR] := {<childw,d> in AllChildWordsAndDeltas with <parentw, lr, childw, d> in ChooseWeightDeltaSet};
set AllCWDeltas := proj(ChooseWeightDeltaSet, <4>);
set CWDeltas[<parentw, lr, childw> in ChooseWeightSet] := {<d> in AllCWDeltas with <parentw, lr, childw, d> in ChooseWeightDeltaSet};

set AllIJ := proj(AllArcs,<2,3>);
param LRForIJ[<i,j> in AllIJ] := if i < j then "r" else "l" end;
set AllArcsDelta := {<s,i,j,d> in {AllArcs * AllCWDeltas} with <Word[s,i],LRForIJ[i,j],Word[s,j],d> in ChooseWeightDeltaSet};

# ---------- Variables for Deltas ----------
var arcDelta[AllArcsDelta] binary;
var cwDelta[ChooseWeightDeltaSet] binary;

# ---------- Constraints for Deltas ----------
# Only one delta is on:
subto only_one_delta: 
	forall <parentw,lr,childw> in ChooseWeightSet:
		1 == (sum <d> in CWDeltas[parentw,lr,childw]: cwDelta[parentw,lr,childw,d]);

# Debug printout:
#do print ChooseWeightSet;
#do forall <parentw,lr,childw> in ChooseWeightSet do print CWDeltas[parentw,lr,childw];
	
# TODO: encoding this as 1.000000001 is a HACK 
# Ensure weights sum to less-than-or-equal 1.0:
subto weights_sum_to_one: 
	forall <parentw, lr> in ParentWordsAndLR: 
		1.0000000001 >= sum <childw,d> in ChildWordsAndDeltas[parentw, lr]:
 				(cwDelta[parentw,lr,childw,d] * ChooseWeightDelta[parentw,lr,childw,d]);

# Ensure that each arcDelta value is correct 
subto arcDelta_correctness:
	forall <s,i,j,d> in AllArcsDelta: 
		arcDelta[s,i,j,d] >= arc[s,i,j] + cwDelta[Word[s,i],LRForIJ[i,j],Word[s,j],d] - 1;

	    ]]>
	</code>
	<code id="deptree-general">
		<![CDATA[
# ---------- Dependency Tree Constraints ----------

# Other tree constraints
# Each node should have a parent (except the wall)
subto one_incoming_arc:
    forall <s> in Sents:
        forall <j> in { 1 to Length[s] }:
	    sum <i> in { 0 to Length[s] } with i != j: arc[s,i,j] == 1;

# The wall has no incoming arcs
subto no_parent_for_wall:
    forall <s> in Sents:
       forall <i> in { 1 to Length[s] }: 
           arc[s,i,0] == 0;

    	]]>
	</code>	
	<code id="deptree-explicit-proj">
    	<![CDATA[   
# ==================================================
# ==== Option 1: Projective parsing ====
# O(n^2) constraints 
# If arc[s,i,j] == 1, then Word[s,i] must dominate all the children under that arc.
# 
# This constraint ensures that Word[s,i] is an ancestor of each of the nodes under the arc.
subto proj_parse_dominate:
    forall <s,i,j> in AllArcs with abs(i-j) > 1:
        vif arc[s,i,j] == 1 then 
            (sum <k,l> in {min(i,j) to max(i,j)}*{min(i,j) to max(i,j)} with k != l and i != l: arc[s,k,l]) == abs(i-j)
        end;

# This constraint ensures that descendents of Word[s,i] are not parents of nodes outside the range [i,j]
subto proj_parse_no_illegal_parents:
    forall <s,i,j> in AllArcs with abs(i-j) > 1:
        vif arc[s,i,j] == 1 then 
            (sum <k,l> in Arcs[s] with (k > min(i,j) and k < max(i,j)) and (l <= min(i,j) or l >= max(i,j)): arc[s,k,l]) == 0 
        end;

# This constraint ensures that Word[s,i]'s parent is not among the nodes under the arc.
subto proj_parse_parent:
    forall <s,i,j> in AllArcs:
        vif arc[s,i,j] == 1 then 
            (sum <k> in {min(i,j) to max(i,j)} with i != k: arc[s,k,i]) == 0 
        end;
# ==================================================
    	
    	]]>
	</code>
	<code id="deptree-flow-nonproj">
    	<![CDATA[   
# ==================================================
# ==== Option 2: Non-projective parsing ====
# Flow Constraints for: B is connected
var flow[AllArcs] real >= 0;

subto flow_sum: 
    forall <s> in Sents:
        Length[s] == sum <j> in { 1 to Length[s] }: flow[s,0,j];

subto flow_diff: 
    forall <s> in Sents:
        forall <i> in { 1 to Length[s] }:
	    1 == (sum <j> in {0 to Length[s] } with i != j: flow[s,j,i])
	         - (sum <j> in { 0 to Length[s] } with i != j: flow[s,i,j]);

subto flow_bound:
    forall <s,i,j> in AllArcs:
        flow[s,i,j] <= Length[s] * arc[s,i,j];
# ==================================================

    	]]>
	</code>
	<code id="deptree-flow-proj">
    	<![CDATA[   
# ==================================================
# ==== Option 4: Projective parsing (also requires constraints from Option 2) ====
# This constraint ensures that descendents of Word[s,i] are not parents of nodes outside the range [i,j]
# and that the parents of those nodes are not outside the range[i,j]
subto proj_parse_no_illegal_parents:
    forall <s,i,j> in AllArcs with abs(i-j) > 1:
        (sum <k,l> in Arcs[s] with (k > min(i,j) and k < max(i,j)) and (l < min(i,j) or l > max(i,j)): (arc[s,k,l] + arc[s,l,k])) <= Length[s] * (1 - arc[s,i,j]); 
# ==================================================

    	]]>
	</code>
	<code id="deptree-multiflow-nonproj">
    	<![CDATA[   
# ==================================================
# ==== Option 5: Multi-commodity flow non-projective parsing ====
# The domain of Arcs is pairs of token indices
set MFlowArcs[<s> in Sents] := {<i,j,k> in Tokens[s] * Tokens[s] * Tokens[s] with i != j and k != 0};
set TempMFlowArcs := union <s> in Sents: MFlowArcs[s];
set AllMFlowArcs := { <s,i,j,k> in Sents*TempMFlowArcs with <i,j,k> in MFlowArcs[s] }; # TODO: this should be horribly slow

# The mflow[s,i,j,k] indicates the flow of commidity k across arc <i,j>
var mflow[AllMFlowArcs] real >= 0 <= 1;

# The root sends one unit of commodity to each node
subto mflow_one_unit: 
    forall <s> in Sents:
       	forall <k> in { 1 to Length[s] }:
       		(sum <j,0,k> in MFlowArcs[s]: mflow[s,j,0,k]) - (sum <0,j,k> in MFlowArcs[s]: mflow[s,0,j,k])
       			== -1;

# Any node consumes its own commodity and no other
subto mflow_self_consumption:
    forall <s> in Sents:
        forall <i> in { 1 to Length[s] }:
        	forall <k> in { 1 to Length[s] }:
        		(sum <j,i,k> in MFlowArcs[s]: mflow[s,j,i,k]) - (sum <i,j,k> in MFlowArcs[s]: mflow[s,i,j,k])
        			== (if i == k then 1 else 0 end);

# Disabled arcs do not carry any flow
subto mflow_disabled:
    forall <s,i,j,k> in AllMFlowArcs:
    	mflow[s,i,j,k] <= arc[s,i,j];
    	
# There are exactly n enabled arcs
subto mflow_enabled:
	forall <s> in Sents:
		Length[s] == sum <i,j> in Arcs[s]: arc[s,i,j];

# Indicates a path from i to j
var path[AllArcs] binary; 

# Path indicator variables 
subto path_one:
	forall <s,j,k> in AllArcs with j != 0 and k != 0:
		path[s,j,k] == sum <i> in Tokens[s] with i != j: mflow[s,i,j,k];
subto path_two:
	forall <s,i,j> in AllArcs with i == 0:
		path[s,i,j] == 1;
subto path_three:
	forall <s,i,j> in AllArcs with j == 0:
		path[s,i,j] == 0;
		
# Indicates a non-projective arc from i to j
var nparc[AllArcs] binary;

subto nparc_one:
	forall <s,i,j> in AllArcs:
		nparc[s,i,j] <= arc[s,i,j];
subto nparc_two:
	forall <s,i,j,k> in AllMFlowArcs with min(i,j) <= k and k <= max(i,j) and i != k:		
		nparc[s,i,j] >= arc[s,i,j] - path[s,i,k];
subto nparc_three:
	forall <s,i,j> in AllArcs:
		nparc[s,i,j] <= - (sum <k> in {min(i,j)+1 to max(i,j)-1}: path[s,i,k]) + abs(j-i) - 1;
	
# ==================================================

    	]]>
	</code>
	<code id="deptree-multiflow-proj">
    	<![CDATA[   
# ==================================================
# ==== Option 6: Projective parsing (also requires constraints from Option 5) ====
subto mf_projective:
	forall <s,i,j> in AllArcs:
		nparc[s,i,j] == 0;
# ==================================================

    	]]>
	</code>
	<code id="deptree-dp-proj">
    	<![CDATA[   
# =====================================================
# ==== Option 3: Dynamic Programming proj. parsing ====

# --------- Dynamic Programming variables ----------
# In the DP formulation arc[] was originally named trap[], but they are equivalent
set DerivArcs[<s> in Sents] := {<i,j,k> in {Tokens[s] * Tokens[s] * Tokens[s]} with i < j and j <= k and i < k and j > 0};
set TempDerivArcs := union <s> in Sents: DerivArcs[s];
set AllDerivArcs := { <s,i,j,k> in Sents*TempDerivArcs with <i,j,k> in DerivArcs[s] }; # TODO: this should be horribly slow

set Triangles[<s> in Sents] := {<i,j> in Tokens[s] * Tokens[s]};
set TempTriangles := union <s> in Sents: Triangles[s];
set AllTriangles := { <s,i,j> in Sents*TempTriangles with <i,j> in Triangles[s] }; # TODO: this should be horribly slow

set DerivTris[<s> in Sents] := {<i,j,k> in {Tokens[s] * Tokens[s] * Tokens[s]} with (i < j and j <= k) or (k <= j and j < i)};
set TempDerivTris := union <s> in Sents: DerivTris[s];
set AllDerivTris := { <s,i,j,k> in Sents*TempDerivTris with <i,j,k> in DerivTris[s] }; # TODO: this should be horribly slow

var deriv_arc[AllDerivArcs] binary;
var tri[AllTriangles] binary;
var deriv_tri[AllDerivTris] binary;

# --------- Dynamic Programming contraints ----------
# A trapazoid from i --> j indicates an arc from parent i to child j

# This constraint says there must be a single final triangle from the
# wall to the end of the sentence.
subto acceptance_criteria:
      forall <s> in Sents:      
      	     tri[s,0,Length[s]] == 1;

# The DP should really start with two separate variables for
# tri[s,1,1] (for the right and left triangles), but instead, we just
# cheat and say that they are both indicated by the same variable and
# the constraints for constructing initial trapezoids should just work.

# This constraint says that each of the zero length triangles is initialized to being on.
subto initialize:
      forall <s,i,j> in AllTriangles with i == j:
      	     tri[s,i,j] == 1;

# Create indicator variables for which derivation we use to create arc[s,i,k] or arc[s,k,i]
# if deriv_arc[s,i,j,k] == 1 then tri[s,i,j-1] == 1 AND tri[s,k,j] == 1
subto deriv_attach:
      forall <s,i,j,k> in AllDerivArcs:
      	     2*deriv_arc[s,i,j,k] <= tri[s,i,j-1] + tri[s,k,j];

# if arc[s,i,k] == 1 then tri[s,i,j-1] and tri[s,j,k] for some valid j (this is like an OR)
#TODO: In the DP attach_right and attach_left are different because the final triangle is on the head side only. Does that matter?
subto attach_right:
      forall <s,i,k> in AllArcs with i < k:
     	    arc[s,i,k] + arc[s,k,i]  <= sum <j> in Tokens[s] with <i,j,k> in DerivArcs[s]: deriv_arc[s,i,j,k];
#subto attach_right:
#      forall <s,i,k> in AllArcs with i < k:
#     	    arc[s,i,k]  <= sum <j> in Tokens[s] with <i,j,k> in DerivArcs[s]: deriv_arc[s,i,j,k];
#subto attach_left:
#      forall <s,i,k> in AllArcs with i < k:
#      	    arc[s,k,i]  <= sum <j> in Tokens[s] with <i,j,k> in DerivArcs[s]: deriv_arc[s,i,j,k];

# Create indicator variables for the derivation of tri[s,i,k] or tri[s,k,i]
# if deriv_tri[s,i,j,k] == 1 then arc[s,i,j] == 1 and tri[s,j,k] == 1
# The case of i < j corresponds to a complete_right, and j < i corresponds to complete_left
subto deriv_complete_right:
      forall <s,i,j,k> in AllDerivTris:
      	     2*deriv_tri[s,i,j,k] <= arc[s,i,j] + tri[s,j,k];

# Complete right/left
subto complete_right_left:
      forall <s> in Sents:
      	     forall <i,k> in {Tokens[s] * Tokens[s]} with (i < k) or (k < i):
	     	    tri[s,i,k] == sum <j> in Tokens[s] with <i,j,k> in DerivTris[s]: deriv_tri[s,i,j,k];
# =====================================================

    	]]>
	</code>
	<code id="dmv-objective-support">
    	<![CDATA[   
# ---------- Supporting variables for DMV log-likelihood ----------

set AllTokensLR := AllTokens * LR;
# number of arcs from <s,i> to left/right children
var numToSide[<s,i,lr> in AllTokensLR] integer >= 0 <= Length[s];
# whether a child was generate adjacent to the left/right
var genAdj[AllTokensLR] binary;
# number of non-adjacent arcs from <s,i> to left/right children
var numNA[<s,i,lr> in AllTokensLR] integer >= 0 <= Length[s] - 1;

subto numToSideLeft:
    forall <s,i> in AllTokens:
        numToSide[s,i,"l"] == sum <j> in { 0 to i-1 }: arc[s,i,j];

subto numToSideRight:
    forall <s,i> in AllTokens:
        numToSide[s,i,"r"] == sum <j> in { i+1 to Length[s] }: arc[s,i,j];

subto genAdjLeftAndRight:
    forall <s,i,lr> in AllTokensLR: 
        vif numToSide[s,i,lr] >= 1 then genAdj[s,i,lr] == 1 else genAdj[s,i,lr] == 0 end;

subto numNALeftAndRight:
    forall <s,i,lr> in AllTokensLR:
        vif numToSide[s,i,lr] - 1 > 0 then numNA[s,i,lr] == numToSide[s,i,lr] - 1 else numNA[s,i,lr] == 0 end;
   	
    	]]>
	</code>
	<code id="dmv-objective">
    	<![CDATA[   
# ---------- DMV log-likelihood ----------

# Prob for stop weights: 
# 1. logprob of stopping adjacent without generating any children OR
# 2. logprob of not stopping adjacent 
#    + logprob of not stopping non-adjacent * number of times non-adjacent children were generated
#    + logprob of stopping non-adajacent 
maximize goal: 
    (sum <s,i,j> in AllArcs: 
        if i < j 
        then arc[s,i,j] * log(ChooseWeight[Word[s,i],"r",Word[s,j]]) 
        else arc[s,i,j] * log(ChooseWeight[Word[s,i],"l",Word[s,j]]) end) 
    + (sum <s,i,lr> in AllTokensLR: 
      	 ((1 - genAdj[s,i,lr]) * log(StopWeight[Word[s,i],lr,1])
	   + genAdj[s,i,lr] * log(1 - StopWeight[Word[s,i],lr,1])
	   + numNA[s,i,lr] * log(1 - StopWeight[Word[s,i],lr,0])
	   + genAdj[s,i,lr] * log(StopWeight[Word[s,i],lr,0]))
      );
    	
    	]]>
	</code>
	<code id="dmv-objective-delta">
    	<![CDATA[   
# ---------- DMV log-likelihood with Deltas ----------

# TODO: add deltas to stopweights
maximize goal: 
    (sum <s,i,j,d> in AllArcsDelta: 
        arcDelta[s,i,j,d] * log(ChooseWeightDelta[Word[s,i],LRForIJ[i,j],Word[s,j],d])) 
    + (sum <s,i,lr> in AllTokensLR: 
      	 ((1 - genAdj[s,i,lr]) * log(StopWeight[Word[s,i],lr,1])
	   + genAdj[s,i,lr] * log(1 - StopWeight[Word[s,i],lr,1])
	   + numNA[s,i,lr] * log(1 - StopWeight[Word[s,i],lr,0])
	   + genAdj[s,i,lr] * log(StopWeight[Word[s,i],lr,0]))
      );
    	
    	]]>
	</code> 
</root>
